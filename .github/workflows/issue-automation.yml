name: Issue Management Automation
on:
  issues:
    types: [opened, labeled]

jobs:
  issue-triage:
    runs-on: ubuntu-latest
    outputs:
      is_epic: ${{ steps.triage.outputs.is_epic }}
      category: ${{ steps.triage.outputs.category }}
      priority: ${{ steps.triage.outputs.priority }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create required labels
        uses: actions/github-script@v7
        with:
          script: |
            // Define all required labels
            const labels = [
              // Category Labels
              { name: 'bug', description: 'Something isn't working', color: 'd73a4a' },
              { name: 'enhancement', description: 'New feature or request', color: 'a2eeef' },
              { name: 'epic', description: 'Large feature requiring multiple sub-tasks', color: '0052cc' },
              { name: 'maintenance', description: 'Maintenance and housekeeping tasks', color: 'f9d0c4' },
              // Priority Labels
              { name: 'priority-critical', description: 'Critical priority issue', color: 'e11d21' },
              { name: 'priority-high', description: 'High priority issue', color: 'fbca04' },
              { name: 'priority-medium', description: 'Medium priority issue', color: 'd4c5f9' },
              { name: 'priority-low', description: 'Low priority issue', color: 'f0f0f0' },
              // Status Labels
              { name: 'needs-triage', description: 'Needs to be reviewed by maintainers', color: 'fbca04' },
              { name: 'needs-review', description: 'Awaiting review from maintainers', color: '0052cc' },
              { name: 'first-time-contributor', description: 'Issue created by first-time contributor', color: '1d76db' }
            ];

            // Create each label if it doesn't exist
            for (const label of labels) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name
                });
                console.log(`Label "${label.name}" already exists`);
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label.name,
                    description: label.description,
                    color: label.color
                  });
                  console.log(`Created label "${label.name}"`);
                } else {
                  console.error(`Error checking/creating label "${label.name}":`, error);
                  throw error;
                }
              }
            }

      - name: Triage issue
        id: triage
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const repo = context.repo;

            // Step 1: Add needs-triage label
            await github.rest.issues.addLabels({
              owner: repo.owner,
              repo: repo.repo,
              issue_number: issue.number,
              labels: ['needs-triage']
            });
            console.log('Added needs-triage label');

            // Step 2: Assign category label
            let category = '';
            const categoryLabels = [];
            if (title.includes('bug')) {
              categoryLabels.push('bug');
              category = 'bug';
            }
            if (title.includes('epic')) {
              categoryLabels.push('epic');
              category = 'epic';
            }
            if (title.includes('maintenance')) {
              categoryLabels.push('maintenance');
              category = 'maintenance';
            }

            if (categoryLabels.length > 0) {
              await github.rest.issues.addLabels({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: issue.number,
                labels: categoryLabels
              });
              console.log(`Added category labels: ${categoryLabels.join(', ')}`);
            }

            // Step 3: Assign priority label
            let priority = 'priority-medium'; // Default
            const content = `${title} ${body}`;

            // Check for critical keywords first
            const criticalKeywords = ['critical', 'urgent', 'production', 'outage'];
            if (criticalKeywords.some(keyword => content.includes(keyword))) {
              priority = 'priority-critical';
            }
            // Then high
            else if (['important', 'high', 'blocking'].some(keyword => content.includes(keyword))) {
              priority = 'priority-high';
            }
            // Then low
            else if (['low', 'nice-to-have', 'minor'].some(keyword => content.includes(keyword))) {
              priority = 'priority-low';
            }

            await github.rest.issues.addLabels({
              owner: repo.owner,
              repo: repo.repo,
              issue_number: issue.number,
              labels: [priority]
            });
            console.log(`Added priority label: ${priority}`);

            // Set outputs
            return {
              is_epic: category === 'epic' ? 'true' : 'false',
              category: category,
              priority: priority
            };

  task-breakdown:
    runs-on: ubuntu-latest
    needs: issue-triage
    if: needs.issue-triage.outputs.is_epic == 'true'
    steps:
      - name: Breakdown epic into sub-tasks
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const repo = context.repo;
            const parentNumber = issue.number;
            const parentTitle = issue.title;
            const subTasks = [
              { number: 1, name: 'Requirements Analysis' },
              { number: 2, name: 'Design and Architecture' },
              { number: 3, name: 'Implementation' },
              { number: 4, name: 'Testing and Documentation' }
            ];
            const subIssueNumbers = [];

            // Create each sub-task
            for (const task of subTasks) {
              const subTitle = `[SUBTASK] ${parentTitle} - Task ${task.number}: ${task.name}`;
              const subBody = `Related to #${parentNumber}`;

              const subIssue = await github.rest.issues.create({
                owner: repo.owner,
                repo: repo.repo,
                title: subTitle,
                body: subBody,
                labels: ['enhancement', 'needs-review']
              });

              subIssueNumbers.push(subIssue.data.number);
              console.log(`Created sub-task #${subIssue.data.number}: ${subTitle}`);
            }

            // Update parent issue with Epic Tasks checklist
            const checklist = subTasks.map((task, index) => 
              `- [ ] #${subIssueNumbers[index]} - ${task.name}`
            ).join('\n');
            const newBody = `${issue.body || ''}\n\n## Epic Tasks\n${checklist}`;

            await github.rest.issues.update({
              owner: repo.owner,
              repo: repo.repo,
              issue_number: parentNumber,
              body: newBody
            });
            console.log('Updated parent issue with Epic Tasks checklist');

  auto-response:
    runs-on: ubuntu-latest
    needs: [issue-triage, task-breakdown]
    if: needs.issue-triage.result == 'success'
    steps:
      - name: Handle auto-response
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const repo = context.repo;
            const author = issue.user.login;
            const category = needs.issue-triage.outputs.category;
            const priority = needs.issue-triage.outputs.priority;

            // Step 1: Check if first-time contributor
            let isFirstIssue = false;
            try {
              const issues = await github.rest.issues.listForRepo({
                owner: repo.owner,
                repo: repo.repo,
                creator: author,
                state: 'all',
                per_page: 100
              });
              // Filter out pull requests
              const authorIssues = issues.data.filter(issue => !issue.pull_request);
              isFirstIssue = authorIssues.length === 1;
            } catch (error) {
              console.error('Error checking first-time contributor:', error);
              // If error, assume not first issue to avoid breaking the workflow
              isFirstIssue = false;
            }

            if (isFirstIssue) {
              await github.rest.issues.addLabels({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: issue.number,
                labels: ['first-time-contributor']
              });
              console.log('Added first-time-contributor label');
            }

            // Step 2: Prepare comment
            let commentBody = '';
            if (isFirstIssue) {
              commentBody += `Welcome @${author}! This is your first issue in this repository. We appreciate your contribution!\n\n`;
            }

            switch (category) {
              case 'bug':
                commentBody += 'Thank you for reporting this bug! Please review our Bug Report Guidelines for more details on how to provide effective bug reports.';
                break;
              case 'epic':
                commentBody += 'Thank you for submitting this epic feature request! Please review our Feature Request Process for more details on how we handle large feature requests.';
                break;
              case 'maintenance':
                commentBody += 'Thank you for reporting this maintenance task! Please review our Maintenance Guidelines for more details on how we handle maintenance tasks.';
                break;
              default:
                commentBody += 'Thank you for your issue! Our team will review it shortly.';
            }

            // Post comment
            await github.rest.issues.createComment({
              owner: repo.owner,
              repo: repo.repo,
              issue_number: issue.number,
              body: commentBody
            });
            console.log('Posted auto-response comment');

            // Step 3: Set milestone for high/critical priority
            const milestoneTitle = 'v1.0.0';
            let milestoneId = null;

            // Check if milestone exists
            try {
              const milestones = await github.rest.issues.listMilestones({
                owner: repo.owner,
                repo: repo.repo,
                state: 'open'
              });
              const existingMilestone = milestones.data.find(m => m.title === milestoneTitle);
              if (existingMilestone) {
                milestoneId = existingMilestone.number;
                console.log(`Found existing milestone ${milestoneTitle} (ID: ${milestoneId})`);
              } else {
                // Create milestone if it doesn't exist
                const newMilestone = await github.rest.issues.createMilestone({
                  owner: repo.owner,
                  repo: repo.repo,
                  title: milestoneTitle,
                  state: 'open'
                });
                milestoneId = newMilestone.data.number;
                console.log(`Created new milestone ${milestoneTitle} (ID: ${milestoneId})`);
              }
            } catch (error) {
              console.error('Error handling milestone:', error);
              // If error, skip setting milestone to avoid breaking the workflow
              milestoneId = null;
            }

            if (milestoneId && (priority === 'priority-high' || priority === 'priority-critical')) {
              await github.rest.issues.update({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: issue.number,
                milestone: milestoneId
              });
              console.log(`Assigned milestone ${milestoneTitle} to issue`);
            }

            // Step 4: Update status from needs-triage to needs-review
            await github.rest.issues.removeLabel({
              owner: repo.owner,
              repo: repo.repo,
              issue_number: issue.number,
              name: 'needs-triage'
            });
            await github.rest.issues.addLabels({
              owner: repo.owner,
              repo: repo.repo,
              issue_number: issue.number,
              labels: ['needs-review']
            });
            console.log('Updated status to needs-review');
